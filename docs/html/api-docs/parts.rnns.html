

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>rnns &mdash; OpenSeq2Seq 0.2 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_override.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_override.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="transformer" href="parts.transformer.html" />
    <link rel="prev" title="parts" href="parts.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> OpenSeq2Seq
          

          
            
            <img src="../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation-instructions.html">Installation instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting-started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../models-and-recipes.html">Models and recipes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../distr-training.html">Distributed training</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mixed-precision.html">Mixed precision training</a></li>
<li class="toctree-l1"><a class="reference internal" href="../in-depth-tutorials.html">In-depth tutorials</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">API documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="models.html">models</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html">data</a></li>
<li class="toctree-l2"><a class="reference internal" href="encoders.html">encoders</a></li>
<li class="toctree-l2"><a class="reference internal" href="decoders.html">decoders</a></li>
<li class="toctree-l2"><a class="reference internal" href="losses.html">losses</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimizers.html">optimizers</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="parts.html">parts</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">rnns</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-parts.rnns.attention_wrapper">attention_wrapper</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-parts.rnns.flstm">flstm</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-parts.rnns.glstm">glstm</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-parts.rnns.gnmt">gnmt</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-parts.rnns.rnn_beam_search_decoder">rnn_beam_search_decoder</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-parts.rnns.slstm">slstm</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-parts.rnns.utils">utils</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="parts.transformer.html">transformer</a></li>
<li class="toctree-l3"><a class="reference internal" href="parts.convs2s.html">convs2s</a></li>
<li class="toctree-l3"><a class="reference internal" href="parts.cnns.html">cnns</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="utils.html">utils</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">OpenSeq2Seq</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="modules.html">API documentation</a> &raquo;</li>
        
          <li><a href="parts.html">parts</a> &raquo;</li>
        
      <li>rnns</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api-docs/parts.rnns.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-parts.rnns">
<span id="rnns"></span><h1>rnns<a class="headerlink" href="#module-parts.rnns" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-parts.rnns.attention_wrapper">
<span id="attention-wrapper"></span><h2>attention_wrapper<a class="headerlink" href="#module-parts.rnns.attention_wrapper" title="Permalink to this headline">¶</a></h2>
<p>A powerful dynamic attention wrapper object.</p>
<dl class="class">
<dt id="parts.rnns.attention_wrapper.AttentionMechanism">
<em class="property">class </em><code class="descclassname">parts.rnns.attention_wrapper.</code><code class="descname">AttentionMechanism</code><a class="reference internal" href="../_modules/parts/rnns/attention_wrapper.html#AttentionMechanism"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.attention_wrapper.AttentionMechanism" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="attribute">
<dt id="parts.rnns.attention_wrapper.AttentionMechanism.alignments_size">
<code class="descname">alignments_size</code><a class="headerlink" href="#parts.rnns.attention_wrapper.AttentionMechanism.alignments_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="parts.rnns.attention_wrapper.AttentionMechanism.state_size">
<code class="descname">state_size</code><a class="headerlink" href="#parts.rnns.attention_wrapper.AttentionMechanism.state_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="parts.rnns.attention_wrapper.AttentionWrapper">
<em class="property">class </em><code class="descclassname">parts.rnns.attention_wrapper.</code><code class="descname">AttentionWrapper</code><span class="sig-paren">(</span><em>cell</em>, <em>attention_mechanism</em>, <em>attention_layer_size=None</em>, <em>alignment_history=False</em>, <em>cell_input_fn=None</em>, <em>output_attention=True</em>, <em>initial_cell_state=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/attention_wrapper.html#AttentionWrapper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.attention_wrapper.AttentionWrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">tensorflow.python.ops.rnn_cell_impl.RNNCell</span></code></p>
<p>Wraps another <cite>RNNCell</cite> with attention.</p>
<dl class="method">
<dt id="parts.rnns.attention_wrapper.AttentionWrapper.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>cell</em>, <em>attention_mechanism</em>, <em>attention_layer_size=None</em>, <em>alignment_history=False</em>, <em>cell_input_fn=None</em>, <em>output_attention=True</em>, <em>initial_cell_state=None</em>, <em>name=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/attention_wrapper.html#AttentionWrapper.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.attention_wrapper.AttentionWrapper.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the <cite>AttentionWrapper</cite>.</p>
<p><strong>NOTE</strong> If you are using the <cite>BeamSearchDecoder</cite> with a cell wrapped in
<cite>AttentionWrapper</cite>, then you must ensure that:</p>
<ul class="simple">
<li>The encoder output has been tiled to <cite>beam_width</cite> via
&#64;{tf.contrib.seq2seq.tile_batch} (NOT <cite>tf.tile</cite>).</li>
<li>The <cite>batch_size</cite> argument passed to the <cite>zero_state</cite> method of this
wrapper is equal to <cite>true_batch_size * beam_width</cite>.</li>
<li>The initial state created with <cite>zero_state</cite> above contains a
<cite>cell_state</cite> value containing properly tiled final state from the
encoder.</li>
</ul>
<p>An example:</p>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a>`
tiled_encoder_outputs = tf.contrib.seq2seq.tile_batch(</p>
<blockquote>
<div>encoder_outputs, multiplier=beam_width)</div></blockquote>
<dl class="docutils">
<dt>tiled_encoder_final_state = tf.conrib.seq2seq.tile_batch(</dt>
<dd>encoder_final_state, multiplier=beam_width)</dd>
<dt>tiled_sequence_length = tf.contrib.seq2seq.tile_batch(</dt>
<dd>sequence_length, multiplier=beam_width)</dd>
<dt>attention_mechanism = MyFavoriteAttentionMechanism(</dt>
<dd>num_units=attention_depth,
memory=tiled_inputs,
memory_sequence_length=tiled_sequence_length)</dd>
</dl>
<p>attention_cell = AttentionWrapper(cell, attention_mechanism, …)
decoder_initial_state = attention_cell.zero_state(</p>
<blockquote>
<div>dtype, batch_size=true_batch_size * beam_width)</div></blockquote>
<dl class="docutils">
<dt>decoder_initial_state = decoder_initial_state.clone(</dt>
<dd>cell_state=tiled_encoder_final_state)</dd>
</dl>
<p><a href="#id3"><span class="problematic" id="id4">``</span></a><a href="#id5"><span class="problematic" id="id6">`</span></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cell</strong> – An instance of <cite>RNNCell</cite>.</li>
<li><strong>attention_mechanism</strong> – A list of <cite>AttentionMechanism</cite> instances or a single
instance.</li>
<li><strong>attention_layer_size</strong> – A list of Python integers or a single Python
integer, the depth of the attention (output) layer(s). If None
(default), use the context as attention at each time step. Otherwise,
feed the context and cell output into the attention layer to generate
attention at each time step. If attention_mechanism is a list,
attention_layer_size must be a list of the same length.</li>
<li><strong>alignment_history</strong> – Python boolean, whether to store alignment history
from all time steps in the final output state (currently stored as a
time major <cite>TensorArray</cite> on which you must call <cite>stack()</cite>).</li>
<li><strong>cell_input_fn</strong> – (optional) A <cite>callable</cite>.  The default is:
<cite>lambda inputs, attention: array_ops.concat([inputs, attention], -1)</cite>.</li>
<li><strong>output_attention</strong> – Python bool.  If <cite>True</cite> (default), the output at each
time step is the attention value.  This is the behavior of Luong-style
attention mechanisms.  If <cite>False</cite>, the output at each time step is
the output of <cite>cell</cite>.  This is the beahvior of Bhadanau-style
attention mechanisms.  In both cases, the <cite>attention</cite> tensor is
propagated to the next time step via the state and is used there.
This flag only controls whether the attention mechanism is propagated
up to the next cell in an RNN stack or to the top RNN output.</li>
<li><strong>initial_cell_state</strong> – The initial state value to use for the cell when
the user calls <cite>zero_state()</cite>.  Note that if this value is provided
now, and the user uses a <cite>batch_size</cite> argument of <cite>zero_state</cite> which
does not match the batch size of <cite>initial_cell_state</cite>, proper
behavior is not guaranteed.</li>
<li><strong>name</strong> – Name to use when creating ops.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code> – <cite>attention_layer_size</cite> is not None and (<cite>attention_mechanism</cite>
is a list but <cite>attention_layer_size</cite> is not; or vice versa).</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – if <cite>attention_layer_size</cite> is not None, <cite>attention_mechanism</cite>
is a list, and its length does not match that of <cite>attention_layer_size</cite>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="parts.rnns.attention_wrapper.AttentionWrapper._item_or_tuple">
<code class="descname">_item_or_tuple</code><span class="sig-paren">(</span><em>seq</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/attention_wrapper.html#AttentionWrapper._item_or_tuple"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.attention_wrapper.AttentionWrapper._item_or_tuple" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <cite>seq</cite> as tuple or the singular element.</p>
<p>Which is returned is determined by how the AttentionMechanism(s) were passed
to the constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>seq</strong> – A non-empty sequence of items or generator.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Either the values in the sequence as a tuple if AttentionMechanism(s)
were passed to the constructor as a sequence or the singular element.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="parts.rnns.attention_wrapper.AttentionWrapper.call">
<code class="descname">call</code><span class="sig-paren">(</span><em>inputs</em>, <em>state</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/attention_wrapper.html#AttentionWrapper.call"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.attention_wrapper.AttentionWrapper.call" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a step of attention-wrapped RNN.</p>
<ul class="simple">
<li>Step 1: Mix the <cite>inputs</cite> and previous step’s <cite>attention</cite> output via
<cite>cell_input_fn</cite>.</li>
<li>Step 2: Call the wrapped <cite>cell</cite> with this input and its previous state.</li>
<li>Step 3: Score the cell’s output with <cite>attention_mechanism</cite>.</li>
<li>Step 4: Calculate the alignments by passing the score through the
<cite>normalizer</cite>.</li>
<li>Step 5: Calculate the context vector as the inner product between the
alignments and the attention_mechanism’s values (memory).</li>
<li>Step 6: Calculate the attention output by concatenating the cell output
and context through the attention layer (a linear layer with
<cite>attention_layer_size</cite> outputs).</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>inputs</strong> – (Possibly nested tuple of) Tensor, the input at this time step.</li>
<li><strong>state</strong> – An instance of <cite>AttentionWrapperState</cite> containing
tensors from the previous time step.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li><cite>attention_or_cell_output</cite> depending on <cite>output_attention</cite>.</li>
<li><dl class="first docutils">
<dt><cite>next_state</cite> is an instance of <cite>AttentionWrapperState</cite></dt>
<dd>containing the state calculated at this time step.</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">A tuple <cite>(attention_or_cell_output, next_state)</cite>, where</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code> – If <cite>state</cite> is not an instance of <cite>AttentionWrapperState</cite>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="parts.rnns.attention_wrapper.AttentionWrapper.output_size">
<code class="descname">output_size</code><a class="headerlink" href="#parts.rnns.attention_wrapper.AttentionWrapper.output_size" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Integer or TensorShape</em> – size of outputs produced by this cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="parts.rnns.attention_wrapper.AttentionWrapper.state_size">
<code class="descname">state_size</code><a class="headerlink" href="#parts.rnns.attention_wrapper.AttentionWrapper.state_size" title="Permalink to this definition">¶</a></dt>
<dd><p>The <cite>state_size</cite> property of <cite>AttentionWrapper</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">An <cite>AttentionWrapperState</cite> tuple containing shapes used by this object.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="parts.rnns.attention_wrapper.AttentionWrapper.zero_state">
<code class="descname">zero_state</code><span class="sig-paren">(</span><em>batch_size</em>, <em>dtype</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/attention_wrapper.html#AttentionWrapper.zero_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.attention_wrapper.AttentionWrapper.zero_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an initial (zero) state tuple for this <cite>AttentionWrapper</cite>.</p>
<p><strong>NOTE</strong> Please see the initializer documentation for details of how
to call <cite>zero_state</cite> if using an <cite>AttentionWrapper</cite> with a
<cite>BeamSearchDecoder</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>batch_size</strong> – <cite>0D</cite> integer tensor: the batch size.</li>
<li><strong>dtype</strong> – The internal state data type.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An <cite>AttentionWrapperState</cite> tuple containing zeroed out tensors and,
possibly, empty <cite>TensorArray</cite> objects.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – (or, possibly at runtime, InvalidArgument), if
<cite>batch_size</cite> does not match the output size of the encoder passed
to the wrapper object at initialization time.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="parts.rnns.attention_wrapper.AttentionWrapperState">
<em class="property">class </em><code class="descclassname">parts.rnns.attention_wrapper.</code><code class="descname">AttentionWrapperState</code><a class="reference internal" href="../_modules/parts/rnns/attention_wrapper.html#AttentionWrapperState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.attention_wrapper.AttentionWrapperState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#parts.rnns.attention_wrapper.AttentionWrapperState" title="parts.rnns.attention_wrapper.AttentionWrapperState"><code class="xref py py-class docutils literal notranslate"><span class="pre">parts.rnns.attention_wrapper.AttentionWrapperState</span></code></a></p>
<p><cite>namedtuple</cite> storing the state of a <cite>AttentionWrapper</cite>.</p>
<p>Contains:</p>
<blockquote>
<div><ul class="simple">
<li><cite>cell_state</cite>: The state of the wrapped <cite>RNNCell</cite> at the previous time
step.</li>
<li><cite>attention</cite>: The attention emitted at the previous time step.</li>
<li><cite>time</cite>: int32 scalar containing the current time step.</li>
<li><dl class="first docutils">
<dt><cite>alignments</cite>: A single or tuple of <a href="#id7"><span class="problematic" id="id8">`</span></a>Tensor`(s) containing the alignments</dt>
<dd>emitted at the previous time step for each attention mechanism.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>alignment_history</cite>: (if enabled) a single or tuple of <a href="#id9"><span class="problematic" id="id10">`</span></a>TensorArray`(s)</dt>
<dd>containing alignment matrices from all time steps for each attention
mechanism. Call <cite>stack()</cite> on each to convert to a <cite>Tensor</cite>.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>attention_state</cite>: A single or tuple of nested objects</dt>
<dd>containing attention mechanism state for each attention mechanism.
The objects may contain Tensors or TensorArrays.</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="parts.rnns.attention_wrapper.AttentionWrapperState.clone">
<code class="descname">clone</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/attention_wrapper.html#AttentionWrapperState.clone"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.attention_wrapper.AttentionWrapperState.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Clone this object, overriding components provided by kwargs.</p>
<p>The new state fields’ shape must match original state fields’ shape. This
will be validated, and original fields’ shape will be propagated to new
fields.</p>
<p>Example:</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">initial_state</span> <span class="pre">=</span> <span class="pre">attention_wrapper.zero_state(dtype=...,</span> <span class="pre">batch_size=...)</span>
<span class="pre">initial_state</span> <span class="pre">=</span> <span class="pre">initial_state.clone(cell_state=encoder_state)</span>
<span class="pre">`</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>**kwargs</strong> – Any properties of the state object to replace in the returned
<cite>AttentionWrapperState</cite>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A new <cite>AttentionWrapperState</cite> whose properties are the same as
this one, except any overridden properties as provided in <cite>kwargs</cite>.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="parts.rnns.attention_wrapper.LuongAttention">
<em class="property">class </em><code class="descclassname">parts.rnns.attention_wrapper.</code><code class="descname">LuongAttention</code><span class="sig-paren">(</span><em>num_units</em>, <em>memory</em>, <em>memory_sequence_length=None</em>, <em>scale=False</em>, <em>probability_fn=None</em>, <em>score_mask_value=None</em>, <em>dtype=None</em>, <em>name='LuongAttention'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/attention_wrapper.html#LuongAttention"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.attention_wrapper.LuongAttention" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">parts.rnns.attention_wrapper._BaseAttentionMechanism</span></code></p>
<p>Implements Luong-style (multiplicative) attention scoring.</p>
<p>This attention has two forms.  The first is standard Luong attention,
as described in:</p>
<p>Minh-Thang Luong, Hieu Pham, Christopher D. Manning.
“Effective Approaches to Attention-based Neural Machine Translation.”
EMNLP 2015.  <a class="reference external" href="https://arxiv.org/abs/1508.04025">https://arxiv.org/abs/1508.04025</a></p>
<p>The second is the scaled form inspired partly by the normalized form of
Bahdanau attention.</p>
<p>To enable the second form, construct the object with parameter
<cite>scale=True</cite>.</p>
<dl class="method">
<dt id="parts.rnns.attention_wrapper.LuongAttention.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>num_units</em>, <em>memory</em>, <em>memory_sequence_length=None</em>, <em>scale=False</em>, <em>probability_fn=None</em>, <em>score_mask_value=None</em>, <em>dtype=None</em>, <em>name='LuongAttention'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/attention_wrapper.html#LuongAttention.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.attention_wrapper.LuongAttention.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the AttentionMechanism mechanism.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>num_units</strong> – The depth of the attention mechanism.</li>
<li><strong>memory</strong> – The memory to query; usually the output of an RNN encoder.  This
tensor should be shaped <cite>[batch_size, max_time, …]</cite>.</li>
<li><strong>memory_sequence_length</strong> – (optional) Sequence lengths for the batch entries
in memory.  If provided, the memory tensor rows are masked with zeros
for values past the respective sequence lengths.</li>
<li><strong>scale</strong> – Python boolean.  Whether to scale the energy term.</li>
<li><strong>probability_fn</strong> – (optional) A <cite>callable</cite>.  Converts the score to
probabilities.  The default is &#64;{tf.nn.softmax}. Other options include
&#64;{tf.contrib.seq2seq.hardmax} and &#64;{tf.contrib.sparsemax.sparsemax}.
Its signature should be: <cite>probabilities = probability_fn(score)</cite>.</li>
<li><strong>score_mask_value</strong> – (optional) The mask value for score before passing into
<cite>probability_fn</cite>. The default is -inf. Only used if
<cite>memory_sequence_length</cite> is not None.</li>
<li><strong>dtype</strong> – The data type for the memory layer of the attention mechanism.</li>
<li><strong>name</strong> – Name to use when creating ops.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="parts.rnns.attention_wrapper.BahdanauAttention">
<em class="property">class </em><code class="descclassname">parts.rnns.attention_wrapper.</code><code class="descname">BahdanauAttention</code><span class="sig-paren">(</span><em>num_units</em>, <em>memory</em>, <em>memory_sequence_length=None</em>, <em>normalize=False</em>, <em>probability_fn=None</em>, <em>score_mask_value=None</em>, <em>dtype=None</em>, <em>name='BahdanauAttention'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/attention_wrapper.html#BahdanauAttention"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.attention_wrapper.BahdanauAttention" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">parts.rnns.attention_wrapper._BaseAttentionMechanism</span></code></p>
<p>Implements Bahdanau-style (additive) attention.</p>
<p>This attention has two forms.  The first is Bahdanau attention,
as described in:</p>
<p>Dzmitry Bahdanau, Kyunghyun Cho, Yoshua Bengio.
“Neural Machine Translation by Jointly Learning to Align and Translate.”
ICLR 2015. <a class="reference external" href="https://arxiv.org/abs/1409.0473">https://arxiv.org/abs/1409.0473</a></p>
<p>The second is the normalized form.  This form is inspired by the
weight normalization article:</p>
<p>Tim Salimans, Diederik P. Kingma.
“Weight Normalization: A Simple Reparameterization to Accelerate</p>
<blockquote>
<div>Training of Deep Neural Networks.”</div></blockquote>
<p><a class="reference external" href="https://arxiv.org/abs/1602.07868">https://arxiv.org/abs/1602.07868</a></p>
<p>To enable the second form, construct the object with parameter
<cite>normalize=True</cite>.</p>
<dl class="method">
<dt id="parts.rnns.attention_wrapper.BahdanauAttention.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>num_units</em>, <em>memory</em>, <em>memory_sequence_length=None</em>, <em>normalize=False</em>, <em>probability_fn=None</em>, <em>score_mask_value=None</em>, <em>dtype=None</em>, <em>name='BahdanauAttention'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/attention_wrapper.html#BahdanauAttention.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.attention_wrapper.BahdanauAttention.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the Attention mechanism.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>num_units</strong> – The depth of the query mechanism.</li>
<li><strong>memory</strong> – The memory to query; usually the output of an RNN encoder.  This
tensor should be shaped <cite>[batch_size, max_time, …]</cite>.</li>
<li><strong>memory_sequence_length</strong> (<em>optional</em>) – Sequence lengths for the batch entries
in memory.  If provided, the memory tensor rows are masked with zeros
for values past the respective sequence lengths.</li>
<li><strong>normalize</strong> – Python boolean.  Whether to normalize the energy term.</li>
<li><strong>probability_fn</strong> – (optional) A <cite>callable</cite>.  Converts the score to
probabilities.  The default is &#64;{tf.nn.softmax}. Other options include
&#64;{tf.contrib.seq2seq.hardmax} and &#64;{tf.contrib.sparsemax.sparsemax}.
Its signature should be: <cite>probabilities = probability_fn(score)</cite>.</li>
<li><strong>score_mask_value</strong> – (optional): The mask value for score before passing into
<cite>probability_fn</cite>. The default is -inf. Only used if
<cite>memory_sequence_length</cite> is not None.</li>
<li><strong>dtype</strong> – The data type for the query and memory layers of the attention
mechanism.</li>
<li><strong>name</strong> – Name to use when creating ops.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="parts.rnns.attention_wrapper.hardmax">
<code class="descclassname">parts.rnns.attention_wrapper.</code><code class="descname">hardmax</code><span class="sig-paren">(</span><em>logits</em>, <em>name=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/attention_wrapper.html#hardmax"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.attention_wrapper.hardmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns batched one-hot vectors.</p>
<p>The depth index containing the <cite>1</cite> is that of the maximum logit value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>logits</strong> – A batch tensor of logit values.</li>
<li><strong>name</strong> – Name to use when creating ops.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A batched one-hot tensor.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="parts.rnns.attention_wrapper.safe_cumprod">
<code class="descclassname">parts.rnns.attention_wrapper.</code><code class="descname">safe_cumprod</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/attention_wrapper.html#safe_cumprod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.attention_wrapper.safe_cumprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes cumprod of x in logspace using cumsum to avoid underflow.</p>
<p>The cumprod function and its gradient can result in numerical instabilities
when its argument has very small and/or zero values.  As long as the argument
is all positive, we can instead compute the cumulative product as
exp(cumsum(log(x))).  This function can be called identically to tf.cumprod.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> – Tensor to take the cumulative product of.</li>
<li><strong>*args</strong> – Passed on to cumsum; these are identical to those in cumprod.</li>
<li><strong>**kwargs</strong> – Passed on to cumsum; these are identical to those in cumprod.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Cumulative product of x.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="parts.rnns.attention_wrapper.monotonic_attention">
<code class="descclassname">parts.rnns.attention_wrapper.</code><code class="descname">monotonic_attention</code><span class="sig-paren">(</span><em>p_choose_i</em>, <em>previous_attention</em>, <em>mode</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/attention_wrapper.html#monotonic_attention"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.attention_wrapper.monotonic_attention" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute monotonic attention distribution from choosing probabilities.</p>
<p>Monotonic attention implies that the input sequence is processed in an
explicitly left-to-right manner when generating the output sequence.  In
addition, once an input sequence element is attended to at a given output
timestep, elements occurring before it cannot be attended to at subsequent
output timesteps.  This function generates attention distributions according
to these assumptions.  For more information, see <a href="#id11"><span class="problematic" id="id12">``</span></a>Online and Linear-Time
Attention by Enforcing Monotonic Alignments’‘.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>p_choose_i</strong> – Probability of choosing input sequence/memory element i.  Should
be of shape (batch_size, input_sequence_length), and should all be in the
range [0, 1].</li>
<li><strong>previous_attention</strong> – The attention distribution from the previous output
timestep.  Should be of shape (batch_size, input_sequence_length).  For
the first output timestep, preevious_attention[n] should be [1, 0, 0, …,
0] for all n in [0, … batch_size - 1].</li>
<li><strong>mode</strong> – <p>How to compute the attention distribution.  Must be one of
‘recursive’, ‘parallel’, or ‘hard’.</p>
<blockquote>
<div><ul>
<li>’recursive’ uses tf.scan to recursively compute the distribution.
This is slowest but is exact, general, and does not suffer from
numerical instabilities.</li>
<li>’parallel’ uses parallelized cumulative-sum and cumulative-product
operations to compute a closed-form solution to the recurrence
relation defining the attention distribution.  This makes it more
efficient than ‘recursive’, but it requires numerical checks which
make the distribution non-exact.  This can be a problem in particular
when input_sequence_length is long and/or p_choose_i has entries very
close to 0 or 1.</li>
<li>’hard’ requires that the probabilities in p_choose_i are all either 0
or 1, and subsequently uses a more efficient and exact solution.</li>
</ul>
</div></blockquote>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A tensor of shape (batch_size, input_sequence_length) representing the
attention distributions for each sequence in the batch.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – mode is not one of ‘recursive’, ‘parallel’, ‘hard’.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="parts.rnns.attention_wrapper.BahdanauMonotonicAttention">
<em class="property">class </em><code class="descclassname">parts.rnns.attention_wrapper.</code><code class="descname">BahdanauMonotonicAttention</code><span class="sig-paren">(</span><em>num_units</em>, <em>memory</em>, <em>memory_sequence_length=None</em>, <em>normalize=False</em>, <em>score_mask_value=None</em>, <em>sigmoid_noise=0.0</em>, <em>sigmoid_noise_seed=None</em>, <em>score_bias_init=0.0</em>, <em>mode='parallel'</em>, <em>dtype=None</em>, <em>name='BahdanauMonotonicAttention'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/attention_wrapper.html#BahdanauMonotonicAttention"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.attention_wrapper.BahdanauMonotonicAttention" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">parts.rnns.attention_wrapper._BaseMonotonicAttentionMechanism</span></code></p>
<p>Monotonic attention mechanism with Bahadanau-style energy function.</p>
<p>This type of attention encorces a monotonic constraint on the attention
distributions; that is once the model attends to a given point in the memory
it can’t attend to any prior points at subsequence output timesteps.  It
achieves this by using the _monotonic_probability_fn instead of softmax to
construct its attention distributions.  Since the attention scores are passed
through a sigmoid, a learnable scalar bias parameter is applied after the
score function and before the sigmoid.  Otherwise, it is equivalent to
BahdanauAttention.  This approach is proposed in</p>
<p>Colin Raffel, Minh-Thang Luong, Peter J. Liu, Ron J. Weiss, Douglas Eck,
“Online and Linear-Time Attention by Enforcing Monotonic Alignments.”
ICML 2017.  <a class="reference external" href="https://arxiv.org/abs/1704.00784">https://arxiv.org/abs/1704.00784</a></p>
<dl class="method">
<dt id="parts.rnns.attention_wrapper.BahdanauMonotonicAttention.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>num_units</em>, <em>memory</em>, <em>memory_sequence_length=None</em>, <em>normalize=False</em>, <em>score_mask_value=None</em>, <em>sigmoid_noise=0.0</em>, <em>sigmoid_noise_seed=None</em>, <em>score_bias_init=0.0</em>, <em>mode='parallel'</em>, <em>dtype=None</em>, <em>name='BahdanauMonotonicAttention'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/attention_wrapper.html#BahdanauMonotonicAttention.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.attention_wrapper.BahdanauMonotonicAttention.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the Attention mechanism.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>num_units</strong> – The depth of the query mechanism.</li>
<li><strong>memory</strong> – The memory to query; usually the output of an RNN encoder.  This
tensor should be shaped <cite>[batch_size, max_time, …]</cite>.</li>
<li><strong>memory_sequence_length</strong> (<em>optional</em>) – Sequence lengths for the batch entries
in memory.  If provided, the memory tensor rows are masked with zeros
for values past the respective sequence lengths.</li>
<li><strong>normalize</strong> – Python boolean.  Whether to normalize the energy term.</li>
<li><strong>score_mask_value</strong> – (optional): The mask value for score before passing into
<cite>probability_fn</cite>. The default is -inf. Only used if
<cite>memory_sequence_length</cite> is not None.</li>
<li><strong>sigmoid_noise</strong> – Standard deviation of pre-sigmoid noise.  See the docstring
for <cite>_monotonic_probability_fn</cite> for more information.</li>
<li><strong>sigmoid_noise_seed</strong> – (optional) Random seed for pre-sigmoid noise.</li>
<li><strong>score_bias_init</strong> – Initial value for score bias scalar.  It’s recommended to
initialize this to a negative value when the length of the memory is
large.</li>
<li><strong>mode</strong> – How to compute the attention distribution.  Must be one of
‘recursive’, ‘parallel’, or ‘hard’.  See the docstring for
<cite>tf.contrib.seq2seq.monotonic_attention</cite> for more information.</li>
<li><strong>dtype</strong> – The data type for the query and memory layers of the attention
mechanism.</li>
<li><strong>name</strong> – Name to use when creating ops.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="parts.rnns.attention_wrapper.LuongMonotonicAttention">
<em class="property">class </em><code class="descclassname">parts.rnns.attention_wrapper.</code><code class="descname">LuongMonotonicAttention</code><span class="sig-paren">(</span><em>num_units</em>, <em>memory</em>, <em>memory_sequence_length=None</em>, <em>scale=False</em>, <em>score_mask_value=None</em>, <em>sigmoid_noise=0.0</em>, <em>sigmoid_noise_seed=None</em>, <em>score_bias_init=0.0</em>, <em>mode='parallel'</em>, <em>dtype=None</em>, <em>name='LuongMonotonicAttention'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/attention_wrapper.html#LuongMonotonicAttention"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.attention_wrapper.LuongMonotonicAttention" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">parts.rnns.attention_wrapper._BaseMonotonicAttentionMechanism</span></code></p>
<p>Monotonic attention mechanism with Luong-style energy function.</p>
<p>This type of attention encorces a monotonic constraint on the attention
distributions; that is once the model attends to a given point in the memory
it can’t attend to any prior points at subsequence output timesteps.  It
achieves this by using the _monotonic_probability_fn instead of softmax to
construct its attention distributions.  Otherwise, it is equivalent to
LuongAttention.  This approach is proposed in</p>
<p>Colin Raffel, Minh-Thang Luong, Peter J. Liu, Ron J. Weiss, Douglas Eck,
“Online and Linear-Time Attention by Enforcing Monotonic Alignments.”
ICML 2017.  <a class="reference external" href="https://arxiv.org/abs/1704.00784">https://arxiv.org/abs/1704.00784</a></p>
<dl class="method">
<dt id="parts.rnns.attention_wrapper.LuongMonotonicAttention.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>num_units</em>, <em>memory</em>, <em>memory_sequence_length=None</em>, <em>scale=False</em>, <em>score_mask_value=None</em>, <em>sigmoid_noise=0.0</em>, <em>sigmoid_noise_seed=None</em>, <em>score_bias_init=0.0</em>, <em>mode='parallel'</em>, <em>dtype=None</em>, <em>name='LuongMonotonicAttention'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/attention_wrapper.html#LuongMonotonicAttention.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.attention_wrapper.LuongMonotonicAttention.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the Attention mechanism.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>num_units</strong> – The depth of the query mechanism.</li>
<li><strong>memory</strong> – The memory to query; usually the output of an RNN encoder.  This
tensor should be shaped <cite>[batch_size, max_time, …]</cite>.</li>
<li><strong>memory_sequence_length</strong> (<em>optional</em>) – Sequence lengths for the batch entries
in memory.  If provided, the memory tensor rows are masked with zeros
for values past the respective sequence lengths.</li>
<li><strong>scale</strong> – Python boolean.  Whether to scale the energy term.</li>
<li><strong>score_mask_value</strong> – (optional): The mask value for score before passing into
<cite>probability_fn</cite>. The default is -inf. Only used if
<cite>memory_sequence_length</cite> is not None.</li>
<li><strong>sigmoid_noise</strong> – Standard deviation of pre-sigmoid noise.  See the docstring
for <cite>_monotonic_probability_fn</cite> for more information.</li>
<li><strong>sigmoid_noise_seed</strong> – (optional) Random seed for pre-sigmoid noise.</li>
<li><strong>score_bias_init</strong> – Initial value for score bias scalar.  It’s recommended to
initialize this to a negative value when the length of the memory is
large.</li>
<li><strong>mode</strong> – How to compute the attention distribution.  Must be one of
‘recursive’, ‘parallel’, or ‘hard’.  See the docstring for
<cite>tf.contrib.seq2seq.monotonic_attention</cite> for more information.</li>
<li><strong>dtype</strong> – The data type for the query and memory layers of the attention
mechanism.</li>
<li><strong>name</strong> – Name to use when creating ops.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-parts.rnns.flstm">
<span id="flstm"></span><h2>flstm<a class="headerlink" href="#module-parts.rnns.flstm" title="Permalink to this headline">¶</a></h2>
<p>Module for constructing RNN Cells.</p>
<dl class="class">
<dt id="parts.rnns.flstm.FLSTMCell">
<em class="property">class </em><code class="descclassname">parts.rnns.flstm.</code><code class="descname">FLSTMCell</code><span class="sig-paren">(</span><em>num_units</em>, <em>fact_size</em>, <em>initializer=None</em>, <em>num_proj=None</em>, <em>forget_bias=1.0</em>, <em>activation=&lt;function tanh&gt;</em>, <em>reuse=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/flstm.html#FLSTMCell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.flstm.FLSTMCell" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">tensorflow.python.ops.rnn_cell_impl.RNNCell</span></code></p>
<p>Group LSTM cell (G-LSTM).
The implementation is based on:</p>
<blockquote>
<div><a class="reference external" href="https://arxiv.org/abs/1703.10722">https://arxiv.org/abs/1703.10722</a></div></blockquote>
<p>O. Kuchaiev and B. Ginsburg
“Factorization Tricks for LSTM Networks”, ICLR 2017 workshop.</p>
<dl class="method">
<dt id="parts.rnns.flstm.FLSTMCell.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>num_units</em>, <em>fact_size</em>, <em>initializer=None</em>, <em>num_proj=None</em>, <em>forget_bias=1.0</em>, <em>activation=&lt;function tanh&gt;</em>, <em>reuse=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/flstm.html#FLSTMCell.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.flstm.FLSTMCell.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the parameters of G-LSTM cell.
:param num_units: int, The number of units in the G-LSTM cell
:param initializer: (optional) The initializer to use for the weight and</p>
<blockquote>
<div>projection matrices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>num_proj</strong> – (optional) int, The output dimensionality for the projection
matrices.  If None, no projection is performed.</li>
<li><strong>forget_bias</strong> – Biases of the forget gate are initialized by default to 1
in order to reduce the scale of forgetting at the beginning of
the training.</li>
<li><strong>activation</strong> – Activation function of the inner states.</li>
<li><strong>reuse</strong> – (optional) Python boolean describing whether to reuse variables
in an existing scope.  If not <cite>True</cite>, and the existing scope already
has the given variables, an error is raised.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – If <cite>num_units</cite> or <cite>num_proj</cite> is not divisible by
<cite>number_of_groups</cite>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="parts.rnns.flstm.FLSTMCell.call">
<code class="descname">call</code><span class="sig-paren">(</span><em>inputs</em>, <em>state</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/flstm.html#FLSTMCell.call"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.flstm.FLSTMCell.call" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="parts.rnns.flstm.FLSTMCell.output_size">
<code class="descname">output_size</code><a class="headerlink" href="#parts.rnns.flstm.FLSTMCell.output_size" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Integer or TensorShape</em> – size of outputs produced by this cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="parts.rnns.flstm.FLSTMCell.state_size">
<code class="descname">state_size</code><a class="headerlink" href="#parts.rnns.flstm.FLSTMCell.state_size" title="Permalink to this definition">¶</a></dt>
<dd><p>size(s) of state(s) used by this cell.</p>
<p>It can be represented by an Integer, a TensorShape or a tuple of Integers
or TensorShapes.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-parts.rnns.glstm">
<span id="glstm"></span><h2>glstm<a class="headerlink" href="#module-parts.rnns.glstm" title="Permalink to this headline">¶</a></h2>
<p>Module for constructing RNN Cells.</p>
<dl class="class">
<dt id="parts.rnns.glstm.GLSTMCell">
<em class="property">class </em><code class="descclassname">parts.rnns.glstm.</code><code class="descname">GLSTMCell</code><span class="sig-paren">(</span><em>num_units</em>, <em>initializer=None</em>, <em>num_proj=None</em>, <em>number_of_groups=1</em>, <em>forget_bias=1.0</em>, <em>activation=&lt;function tanh&gt;</em>, <em>reuse=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/glstm.html#GLSTMCell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.glstm.GLSTMCell" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">tensorflow.python.ops.rnn_cell_impl.RNNCell</span></code></p>
<p>Group LSTM cell (G-LSTM).
The implementation is based on:</p>
<blockquote>
<div><a class="reference external" href="https://arxiv.org/abs/1703.10722">https://arxiv.org/abs/1703.10722</a></div></blockquote>
<p>O. Kuchaiev and B. Ginsburg
“Factorization Tricks for LSTM Networks”, ICLR 2017 workshop.</p>
<dl class="method">
<dt id="parts.rnns.glstm.GLSTMCell.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>num_units</em>, <em>initializer=None</em>, <em>num_proj=None</em>, <em>number_of_groups=1</em>, <em>forget_bias=1.0</em>, <em>activation=&lt;function tanh&gt;</em>, <em>reuse=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/glstm.html#GLSTMCell.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.glstm.GLSTMCell.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the parameters of G-LSTM cell.
:param num_units: int, The number of units in the G-LSTM cell
:param initializer: (optional) The initializer to use for the weight and</p>
<blockquote>
<div>projection matrices.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>num_proj</strong> – (optional) int, The output dimensionality for the projection
matrices.  If None, no projection is performed.</li>
<li><strong>number_of_groups</strong> – (optional) int, number of groups to use.
If <cite>number_of_groups</cite> is 1, then it should be equivalent to LSTM cell</li>
<li><strong>forget_bias</strong> – Biases of the forget gate are initialized by default to 1
in order to reduce the scale of forgetting at the beginning of
the training.</li>
<li><strong>activation</strong> – Activation function of the inner states.</li>
<li><strong>reuse</strong> – (optional) Python boolean describing whether to reuse variables
in an existing scope.  If not <cite>True</cite>, and the existing scope already
has the given variables, an error is raised.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – If <cite>num_units</cite> or <cite>num_proj</cite> is not divisible by
<cite>number_of_groups</cite>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="parts.rnns.glstm.GLSTMCell._get_input_for_group">
<code class="descname">_get_input_for_group</code><span class="sig-paren">(</span><em>inputs</em>, <em>group_id</em>, <em>group_size</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/glstm.html#GLSTMCell._get_input_for_group"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.glstm.GLSTMCell._get_input_for_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Slices inputs into groups to prepare for processing by cell’s groups
:param inputs: cell input or it’s previous state,</p>
<blockquote>
<div>a Tensor, 2D, [batch x num_units]</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>group_id</strong> – group id, a Scalar, for which to prepare input</li>
<li><strong>group_size</strong> – size of the group</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">subset of inputs corresponding to group “group_id”,
a Tensor, 2D, [batch x num_units/number_of_groups]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="parts.rnns.glstm.GLSTMCell.call">
<code class="descname">call</code><span class="sig-paren">(</span><em>inputs</em>, <em>state</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/glstm.html#GLSTMCell.call"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.glstm.GLSTMCell.call" title="Permalink to this definition">¶</a></dt>
<dd><p>Run one step of G-LSTM.
:param inputs: input Tensor, 2D, [batch x num_units].
:param state: this must be a tuple of state Tensors, both <cite>2-D</cite>,
:param with column sizes <cite>c_state</cite> and <cite>m_state</cite>.:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul>
<li>A <cite>2-D, [batch x output_dim]</cite>, Tensor representing the output of the
G-LSTM after reading <cite>inputs</cite> when previous state was <cite>state</cite>.
Here output_dim is:<blockquote>
<div>num_proj if num_proj was set,
num_units otherwise.</div></blockquote>
</li>
<li>LSTMStateTuple representing the new state of G-LSTM cell
after reading <cite>inputs</cite> when the previous state was <cite>state</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">A tuple containing</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – If input size cannot be inferred from inputs via
static shape inference.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="parts.rnns.glstm.GLSTMCell.output_size">
<code class="descname">output_size</code><a class="headerlink" href="#parts.rnns.glstm.GLSTMCell.output_size" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Integer or TensorShape</em> – size of outputs produced by this cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="parts.rnns.glstm.GLSTMCell.state_size">
<code class="descname">state_size</code><a class="headerlink" href="#parts.rnns.glstm.GLSTMCell.state_size" title="Permalink to this definition">¶</a></dt>
<dd><p>size(s) of state(s) used by this cell.</p>
<p>It can be represented by an Integer, a TensorShape or a tuple of Integers
or TensorShapes.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-parts.rnns.gnmt">
<span id="gnmt"></span><h2>gnmt<a class="headerlink" href="#module-parts.rnns.gnmt" title="Permalink to this headline">¶</a></h2>
<p>GNMT attention sequence-to-sequence model with dynamic RNN support.</p>
<dl class="class">
<dt id="parts.rnns.gnmt.GNMTAttentionMultiCell">
<em class="property">class </em><code class="descclassname">parts.rnns.gnmt.</code><code class="descname">GNMTAttentionMultiCell</code><span class="sig-paren">(</span><em>attention_cell</em>, <em>cells</em>, <em>use_new_attention=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/gnmt.html#GNMTAttentionMultiCell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.gnmt.GNMTAttentionMultiCell" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">tensorflow.python.ops.rnn_cell_impl.MultiRNNCell</span></code></p>
<p>A MultiCell with GNMT attention style.</p>
<dl class="method">
<dt id="parts.rnns.gnmt.GNMTAttentionMultiCell.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>attention_cell</em>, <em>cells</em>, <em>use_new_attention=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/gnmt.html#GNMTAttentionMultiCell.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.gnmt.GNMTAttentionMultiCell.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a GNMTAttentionMultiCell.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>attention_cell</strong> – An instance of AttentionWrapper.</li>
<li><strong>cells</strong> – A list of RNNCell wrapped with AttentionInputWrapper.</li>
<li><strong>use_new_attention</strong> – Whether to use the attention generated from current
step bottom layer’s output. Default is False.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="parts.rnns.gnmt.gnmt_residual_fn">
<code class="descclassname">parts.rnns.gnmt.</code><code class="descname">gnmt_residual_fn</code><span class="sig-paren">(</span><em>inputs</em>, <em>outputs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/gnmt.html#gnmt_residual_fn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.gnmt.gnmt_residual_fn" title="Permalink to this definition">¶</a></dt>
<dd><p>Residual function that handles different inputs and outputs inner dims.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>inputs</strong> – cell inputs, this is actual inputs concatenated with the attention
vector.</li>
<li><strong>outputs</strong> – cell outputs</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">outputs + actual inputs</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-parts.rnns.rnn_beam_search_decoder">
<span id="rnn-beam-search-decoder"></span><h2>rnn_beam_search_decoder<a class="headerlink" href="#module-parts.rnns.rnn_beam_search_decoder" title="Permalink to this headline">¶</a></h2>
<p>A decoder that performs beam search.</p>
<dl class="class">
<dt id="parts.rnns.rnn_beam_search_decoder.BeamSearchDecoderOutput">
<em class="property">class </em><code class="descclassname">parts.rnns.rnn_beam_search_decoder.</code><code class="descname">BeamSearchDecoderOutput</code><a class="reference internal" href="../_modules/parts/rnns/rnn_beam_search_decoder.html#BeamSearchDecoderOutput"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.rnn_beam_search_decoder.BeamSearchDecoderOutput" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#parts.rnns.rnn_beam_search_decoder.BeamSearchDecoderOutput" title="parts.rnns.rnn_beam_search_decoder.BeamSearchDecoderOutput"><code class="xref py py-class docutils literal notranslate"><span class="pre">parts.rnns.rnn_beam_search_decoder.BeamSearchDecoderOutput</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="parts.rnns.rnn_beam_search_decoder.BeamSearchDecoderState">
<em class="property">class </em><code class="descclassname">parts.rnns.rnn_beam_search_decoder.</code><code class="descname">BeamSearchDecoderState</code><a class="reference internal" href="../_modules/parts/rnns/rnn_beam_search_decoder.html#BeamSearchDecoderState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.rnn_beam_search_decoder.BeamSearchDecoderState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#parts.rnns.rnn_beam_search_decoder.BeamSearchDecoderState" title="parts.rnns.rnn_beam_search_decoder.BeamSearchDecoderState"><code class="xref py py-class docutils literal notranslate"><span class="pre">parts.rnns.rnn_beam_search_decoder.BeamSearchDecoderState</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="parts.rnns.rnn_beam_search_decoder.BeamSearchDecoder">
<em class="property">class </em><code class="descclassname">parts.rnns.rnn_beam_search_decoder.</code><code class="descname">BeamSearchDecoder</code><span class="sig-paren">(</span><em>cell</em>, <em>embedding</em>, <em>start_tokens</em>, <em>end_token</em>, <em>initial_state</em>, <em>beam_width</em>, <em>output_layer=None</em>, <em>length_penalty_weight=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/rnn_beam_search_decoder.html#BeamSearchDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.rnn_beam_search_decoder.BeamSearchDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">tensorflow.contrib.seq2seq.python.ops.decoder.Decoder</span></code></p>
<p>BeamSearch sampling decoder.</p>
<p><strong>NOTE</strong> If you are using the <cite>BeamSearchDecoder</cite> with a cell wrapped in
<cite>AttentionWrapper</cite>, then you must ensure that:</p>
<ul class="simple">
<li>The encoder output has been tiled to <cite>beam_width</cite> via
&#64;{tf.contrib.seq2seq.tile_batch} (NOT <cite>tf.tile</cite>).</li>
<li>The <cite>batch_size</cite> argument passed to the <cite>zero_state</cite> method of this
wrapper is equal to <cite>true_batch_size * beam_width</cite>.</li>
<li>The initial state created with <cite>zero_state</cite> above contains a
<cite>cell_state</cite> value containing properly tiled final state from the
encoder.</li>
</ul>
<p>An example:</p>
<p><a href="#id13"><span class="problematic" id="id14">``</span></a>`
tiled_encoder_outputs = tf.contrib.seq2seq.tile_batch(</p>
<blockquote>
<div>encoder_outputs, multiplier=beam_width)</div></blockquote>
<dl class="docutils">
<dt>tiled_encoder_final_state = tf.conrib.seq2seq.tile_batch(</dt>
<dd>encoder_final_state, multiplier=beam_width)</dd>
<dt>tiled_sequence_length = tf.contrib.seq2seq.tile_batch(</dt>
<dd>sequence_length, multiplier=beam_width)</dd>
<dt>attention_mechanism = MyFavoriteAttentionMechanism(</dt>
<dd>num_units=attention_depth,
memory=tiled_inputs,
memory_sequence_length=tiled_sequence_length)</dd>
</dl>
<p>attention_cell = AttentionWrapper(cell, attention_mechanism, …)
decoder_initial_state = attention_cell.zero_state(</p>
<blockquote>
<div>dtype, batch_size=true_batch_size * beam_width)</div></blockquote>
<dl class="docutils">
<dt>decoder_initial_state = decoder_initial_state.clone(</dt>
<dd>cell_state=tiled_encoder_final_state)</dd>
</dl>
<p><a href="#id15"><span class="problematic" id="id16">``</span></a><a href="#id17"><span class="problematic" id="id18">`</span></a></p>
<dl class="method">
<dt id="parts.rnns.rnn_beam_search_decoder.BeamSearchDecoder.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>cell</em>, <em>embedding</em>, <em>start_tokens</em>, <em>end_token</em>, <em>initial_state</em>, <em>beam_width</em>, <em>output_layer=None</em>, <em>length_penalty_weight=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/rnn_beam_search_decoder.html#BeamSearchDecoder.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.rnn_beam_search_decoder.BeamSearchDecoder.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the BeamSearchDecoder.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cell</strong> – An <cite>RNNCell</cite> instance.</li>
<li><strong>embedding</strong> – A callable that takes a vector tensor of <cite>ids</cite> (argmax ids),
or the <cite>params</cite> argument for <cite>embedding_lookup</cite>.</li>
<li><strong>start_tokens</strong> – <cite>int32</cite> vector shaped <cite>[batch_size]</cite>, the start tokens.</li>
<li><strong>end_token</strong> – <cite>int32</cite> scalar, the token that marks end of decoding.</li>
<li><strong>initial_state</strong> – A (possibly nested tuple of…) tensors and TensorArrays.</li>
<li><strong>beam_width</strong> – Python integer, the number of beams.</li>
<li><strong>output_layer</strong> – (Optional) An instance of <cite>tf.layers.Layer</cite>, i.e.,
<cite>tf.layers.Dense</cite>.  Optional layer to apply to the RNN output prior
to storing the result or sampling.</li>
<li><strong>length_penalty_weight</strong> – Float weight to penalize length. Disabled with 0.0.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code> – if <cite>cell</cite> is not an instance of <cite>RNNCell</cite>,
or <cite>output_layer</cite> is not an instance of <cite>tf.layers.Layer</cite>.</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – If <cite>start_tokens</cite> is not a vector or
<cite>end_token</cite> is not a scalar.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="parts.rnns.rnn_beam_search_decoder.BeamSearchDecoder._maybe_merge_batch_beams">
<code class="descname">_maybe_merge_batch_beams</code><span class="sig-paren">(</span><em>t</em>, <em>s</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/rnn_beam_search_decoder.html#BeamSearchDecoder._maybe_merge_batch_beams"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.rnn_beam_search_decoder.BeamSearchDecoder._maybe_merge_batch_beams" title="Permalink to this definition">¶</a></dt>
<dd><p>Splits the tensor from a batch by beams into a batch of beams.</p>
<p>More exactly, <cite>t</cite> is a tensor of dimension <cite>[batch_size * beam_width] + s</cite>,
then we reshape it to <cite>[batch_size, beam_width] + s</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>t</strong> – <cite>Tensor</cite> of dimension <cite>[batch_size * beam_width] + s</cite>.</li>
<li><strong>s</strong> – <cite>Tensor</cite>, Python int, or <cite>TensorShape</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A reshaped version of t with shape <cite>[batch_size, beam_width] + s</cite>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code> – If <cite>t</cite> is an instance of <cite>TensorArray</cite>.</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – If the rank of <cite>t</cite> is not statically known.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="parts.rnns.rnn_beam_search_decoder.BeamSearchDecoder._maybe_split_batch_beams">
<code class="descname">_maybe_split_batch_beams</code><span class="sig-paren">(</span><em>t</em>, <em>s</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/rnn_beam_search_decoder.html#BeamSearchDecoder._maybe_split_batch_beams"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.rnn_beam_search_decoder.BeamSearchDecoder._maybe_split_batch_beams" title="Permalink to this definition">¶</a></dt>
<dd><p>Maybe splits the tensor from a batch by beams into a batch of beams.</p>
<p>We do this so that we can use nest and not run into problems with shapes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>t</strong> – <cite>Tensor</cite>, either scalar or shaped <cite>[batch_size * beam_width] + s</cite>.</li>
<li><strong>s</strong> – <cite>Tensor</cite>, Python int, or <cite>TensorShape</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">If <cite>t</cite> is a matrix or higher order tensor, then the return value is
<cite>t</cite> reshaped to <cite>[batch_size, beam_width] + s</cite>.  Otherwise <cite>t</cite> is
returned unchanged.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code> – If <cite>t</cite> is an instance of <cite>TensorArray</cite>.</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – If the rank of <cite>t</cite> is not statically known.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="parts.rnns.rnn_beam_search_decoder.BeamSearchDecoder._merge_batch_beams">
<code class="descname">_merge_batch_beams</code><span class="sig-paren">(</span><em>t</em>, <em>s=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/rnn_beam_search_decoder.html#BeamSearchDecoder._merge_batch_beams"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.rnn_beam_search_decoder.BeamSearchDecoder._merge_batch_beams" title="Permalink to this definition">¶</a></dt>
<dd><p>Merges the tensor from a batch of beams into a batch by beams.</p>
<p>More exactly, t is a tensor of dimension [batch_size, beam_width, s]. We
reshape this into [batch_size*beam_width, s]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>t</strong> – Tensor of dimension [batch_size, beam_width, s]</li>
<li><strong>s</strong> – (Possibly known) depth shape.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A reshaped version of t with dimension [batch_size * beam_width, s].</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="parts.rnns.rnn_beam_search_decoder.BeamSearchDecoder._split_batch_beams">
<code class="descname">_split_batch_beams</code><span class="sig-paren">(</span><em>t</em>, <em>s=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/rnn_beam_search_decoder.html#BeamSearchDecoder._split_batch_beams"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.rnn_beam_search_decoder.BeamSearchDecoder._split_batch_beams" title="Permalink to this definition">¶</a></dt>
<dd><p>Splits the tensor from a batch by beams into a batch of beams.</p>
<p>More exactly, t is a tensor of dimension [batch_size*beam_width, s]. We
reshape this into [batch_size, beam_width, s]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>t</strong> – Tensor of dimension [batch_size*beam_width, s].</li>
<li><strong>s</strong> – (Possibly known) depth shape.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A reshaped version of t with dimension [batch_size, beam_width, s].</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – If, after reshaping, the new tensor is not shaped
<cite>[batch_size, beam_width, s]</cite> (assuming batch_size and beam_width
are known statically).</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="parts.rnns.rnn_beam_search_decoder.BeamSearchDecoder.batch_size">
<code class="descname">batch_size</code><a class="headerlink" href="#parts.rnns.rnn_beam_search_decoder.BeamSearchDecoder.batch_size" title="Permalink to this definition">¶</a></dt>
<dd><p>The batch size of input values.</p>
</dd></dl>

<dl class="method">
<dt id="parts.rnns.rnn_beam_search_decoder.BeamSearchDecoder.finalize">
<code class="descname">finalize</code><span class="sig-paren">(</span><em>outputs</em>, <em>final_state</em>, <em>sequence_lengths</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/rnn_beam_search_decoder.html#BeamSearchDecoder.finalize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.rnn_beam_search_decoder.BeamSearchDecoder.finalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Finalize and return the predicted_ids.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>outputs</strong> – An instance of BeamSearchDecoderOutput.</li>
<li><strong>final_state</strong> – An instance of BeamSearchDecoderState. Passed through to the
output.</li>
<li><strong>sequence_lengths</strong> – An <cite>int64</cite> tensor shaped <cite>[batch_size, beam_width]</cite>.
The sequence lengths determined for each beam during decode.
<strong>NOTE</strong> These are ignored; the updated sequence lengths are stored in
<cite>final_state.lengths</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><dl class="docutils">
<dt>An instance of <cite>FinalBeamSearchDecoderOutput</cite> where the</dt>
<dd><p class="first last">predicted_ids are the result of calling _gather_tree.</p>
</dd>
</dl>
<p>final_state: The same input instance of <cite>BeamSearchDecoderState</cite>.</p>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">outputs</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="parts.rnns.rnn_beam_search_decoder.BeamSearchDecoder.initialize">
<code class="descname">initialize</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/rnn_beam_search_decoder.html#BeamSearchDecoder.initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.rnn_beam_search_decoder.BeamSearchDecoder.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the decoder.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> – Name scope for any created operations.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><cite>(finished, start_inputs, initial_state)</cite>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="parts.rnns.rnn_beam_search_decoder.BeamSearchDecoder.output_dtype">
<code class="descname">output_dtype</code><a class="headerlink" href="#parts.rnns.rnn_beam_search_decoder.BeamSearchDecoder.output_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>A (possibly nested tuple of…) dtype[s].</p>
</dd></dl>

<dl class="attribute">
<dt id="parts.rnns.rnn_beam_search_decoder.BeamSearchDecoder.output_size">
<code class="descname">output_size</code><a class="headerlink" href="#parts.rnns.rnn_beam_search_decoder.BeamSearchDecoder.output_size" title="Permalink to this definition">¶</a></dt>
<dd><p>A (possibly nested tuple of…) integer[s] or <cite>TensorShape</cite> object[s].</p>
</dd></dl>

<dl class="method">
<dt id="parts.rnns.rnn_beam_search_decoder.BeamSearchDecoder.step">
<code class="descname">step</code><span class="sig-paren">(</span><em>time</em>, <em>inputs</em>, <em>state</em>, <em>name=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/rnn_beam_search_decoder.html#BeamSearchDecoder.step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.rnn_beam_search_decoder.BeamSearchDecoder.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a decoding step.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>time</strong> – scalar <cite>int32</cite> tensor.</li>
<li><strong>inputs</strong> – A (structure of) input tensors.</li>
<li><strong>state</strong> – A (structure of) state tensors and TensorArrays.</li>
<li><strong>name</strong> – Name scope for any created operations.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><cite>(outputs, next_state, next_inputs, finished)</cite>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="parts.rnns.rnn_beam_search_decoder.BeamSearchDecoder.tracks_own_finished">
<code class="descname">tracks_own_finished</code><a class="headerlink" href="#parts.rnns.rnn_beam_search_decoder.BeamSearchDecoder.tracks_own_finished" title="Permalink to this definition">¶</a></dt>
<dd><p>The BeamSearchDecoder shuffles its beams and their finished state.</p>
<p>For this reason, it conflicts with the <cite>dynamic_decode</cite> function’s
tracking of finished states.  Setting this property to true avoids
early stopping of decoding due to mismanagement of the finished state
in <cite>dynamic_decode</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><cite>True</cite>.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="parts.rnns.rnn_beam_search_decoder.FinalBeamSearchDecoderOutput">
<em class="property">class </em><code class="descclassname">parts.rnns.rnn_beam_search_decoder.</code><code class="descname">FinalBeamSearchDecoderOutput</code><a class="reference internal" href="../_modules/parts/rnns/rnn_beam_search_decoder.html#FinalBeamSearchDecoderOutput"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.rnn_beam_search_decoder.FinalBeamSearchDecoderOutput" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">parts.rnns.rnn_beam_search_decoder.FinalBeamDecoderOutput</span></code></p>
<p>Final outputs returned by the beam search after all decoding is finished.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>predicted_ids</strong> – The final prediction. A tensor of shape
<cite>[batch_size, T, beam_width]</cite> (or <cite>[T, batch_size, beam_width]</cite> if
<cite>output_time_major</cite> is True). Beams are ordered from best to worst.</li>
<li><strong>beam_search_decoder_output</strong> – An instance of <cite>BeamSearchDecoderOutput</cite> that
describes the state of the beam search.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="parts.rnns.rnn_beam_search_decoder.tile_batch">
<code class="descclassname">parts.rnns.rnn_beam_search_decoder.</code><code class="descname">tile_batch</code><span class="sig-paren">(</span><em>t</em>, <em>multiplier</em>, <em>name=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/rnn_beam_search_decoder.html#tile_batch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.rnn_beam_search_decoder.tile_batch" title="Permalink to this definition">¶</a></dt>
<dd><p>Tile the batch dimension of a (possibly nested structure of) tensor(s) t.</p>
<p>For each tensor t in a (possibly nested structure) of tensors,
this function takes a tensor t shaped <cite>[batch_size, s0, s1, …]</cite> composed of
minibatch entries <cite>t[0], …, t[batch_size - 1]</cite> and tiles it to have a shape
<cite>[batch_size * multiplier, s0, s1, …]</cite> composed of minibatch entries
<cite>t[0], t[0], …, t[1], t[1], …</cite> where each minibatch entry is repeated
<cite>multiplier</cite> times.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>t</strong> – <cite>Tensor</cite> shaped <cite>[batch_size, …]</cite>.</li>
<li><strong>multiplier</strong> – Python int.</li>
<li><strong>name</strong> – Name scope for any created operations.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A (possibly nested structure of) <cite>Tensor</cite> shaped
<cite>[batch_size * multiplier, …]</cite>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – if tensor(s) <cite>t</cite> do not have a statically known rank or</li>
<li>the rank is &lt; 1.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-parts.rnns.slstm">
<span id="slstm"></span><h2>slstm<a class="headerlink" href="#module-parts.rnns.slstm" title="Permalink to this headline">¶</a></h2>
<p>Implement <a class="reference external" href="https://arxiv.org/abs/1709.02755">https://arxiv.org/abs/1709.02755</a></p>
<p>Copy from LSTM, and make it functionally correct with minimum code change</p>
<dl class="class">
<dt id="parts.rnns.slstm.BasicSLSTMCell">
<em class="property">class </em><code class="descclassname">parts.rnns.slstm.</code><code class="descname">BasicSLSTMCell</code><span class="sig-paren">(</span><em>num_units</em>, <em>forget_bias=1.0</em>, <em>state_is_tuple=True</em>, <em>activation=None</em>, <em>reuse=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/slstm.html#BasicSLSTMCell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.slstm.BasicSLSTMCell" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">tensorflow.python.ops.rnn_cell_impl.RNNCell</span></code></p>
<p>Basic SLSTM recurrent network cell.</p>
<p>The implementation is based on: <a class="reference external" href="https://arxiv.org/abs/1709.02755">https://arxiv.org/abs/1709.02755</a>.</p>
<dl class="method">
<dt id="parts.rnns.slstm.BasicSLSTMCell.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>num_units</em>, <em>forget_bias=1.0</em>, <em>state_is_tuple=True</em>, <em>activation=None</em>, <em>reuse=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/slstm.html#BasicSLSTMCell.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.slstm.BasicSLSTMCell.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the basic SLSTM cell.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>num_units</strong> – int, The number of units in the SLSTM cell.</li>
<li><strong>forget_bias</strong> – float, The bias added to forget gates (see above).
Must set to <cite>0.0</cite> manually when restoring from CudnnLSTM-trained
checkpoints.</li>
<li><strong>state_is_tuple</strong> – If True, accepted and returned states are 2-tuples of
the <cite>c_state</cite> and <cite>m_state</cite>.  If False, they are concatenated
along the column axis.  The latter behavior will soon be deprecated.</li>
<li><strong>activation</strong> – Activation function of the inner states.  Default: <cite>tanh</cite>.</li>
<li><strong>reuse</strong> – (optional) Python boolean describing whether to reuse variables
in an existing scope.  If not <cite>True</cite>, and the existing scope already has
the given variables, an error is raised.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="parts.rnns.slstm.BasicSLSTMCell.call">
<code class="descname">call</code><span class="sig-paren">(</span><em>inputs</em>, <em>state</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/slstm.html#BasicSLSTMCell.call"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.slstm.BasicSLSTMCell.call" title="Permalink to this definition">¶</a></dt>
<dd><p>Long short-term memory cell (LSTM).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>inputs</strong> – <cite>2-D</cite> tensor with shape <cite>[batch_size x input_size]</cite>.</li>
<li><strong>state</strong> – An <cite>LSTMStateTuple</cite> of state tensors, each shaped
<cite>[batch_size x self.state_size]</cite>, if <cite>state_is_tuple</cite> has been set to
<cite>True</cite>.  Otherwise, a <cite>Tensor</cite> shaped
<cite>[batch_size x 2 * self.state_size]</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>A pair containing the new hidden state, and the new state (either a</dt>
<dd><p class="first last"><cite>LSTMStateTuple</cite> or a concatenated state, depending on
<cite>state_is_tuple</cite>).</p>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="parts.rnns.slstm.BasicSLSTMCell.output_size">
<code class="descname">output_size</code><a class="headerlink" href="#parts.rnns.slstm.BasicSLSTMCell.output_size" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Integer or TensorShape</em> – size of outputs produced by this cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="parts.rnns.slstm.BasicSLSTMCell.state_size">
<code class="descname">state_size</code><a class="headerlink" href="#parts.rnns.slstm.BasicSLSTMCell.state_size" title="Permalink to this definition">¶</a></dt>
<dd><p>size(s) of state(s) used by this cell.</p>
<p>It can be represented by an Integer, a TensorShape or a tuple of Integers
or TensorShapes.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="parts.rnns.slstm._linear">
<code class="descclassname">parts.rnns.slstm.</code><code class="descname">_linear</code><span class="sig-paren">(</span><em>args</em>, <em>output_size</em>, <em>bias</em>, <em>bias_initializer=None</em>, <em>kernel_initializer=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/slstm.html#_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.slstm._linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Linear map: sum_i(args[i] * W[i]), where W[i] is a variable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>args</strong> – a 2D Tensor or a list of 2D, batch x n, Tensors.</li>
<li><strong>output_size</strong> – int, second dimension of W[i].</li>
<li><strong>bias</strong> – boolean, whether to add a bias term or not.</li>
<li><strong>bias_initializer</strong> – starting value to initialize the bias
(default is all zeros).</li>
<li><strong>kernel_initializer</strong> – starting value to initialize the weight.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A 2D Tensor with shape [batch x output_size] equal to
sum_i(args[i] * W[i]), where W[i]s are newly created matrices.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – if some of the arguments has unspecified or wrong shape.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-parts.rnns.utils">
<span id="utils"></span><h2>utils<a class="headerlink" href="#module-parts.rnns.utils" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="parts.rnns.utils.single_cell">
<code class="descclassname">parts.rnns.utils.</code><code class="descname">single_cell</code><span class="sig-paren">(</span><em>cell_class</em>, <em>cell_params</em>, <em>dp_input_keep_prob=1.0</em>, <em>dp_output_keep_prob=1.0</em>, <em>residual_connections=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/parts/rnns/utils.html#single_cell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#parts.rnns.utils.single_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an instance of the rnn cell.
Such cell describes one step one layer and can include residual connection
and/or dropout</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>cell_class</strong> – Tensorflow RNN cell class</li>
<li><strong>cell_params</strong> (<em>dict</em>) – cell parameters</li>
<li><strong>dp_input_keep_prob</strong> (<em>float</em>) – (default: 1.0) input dropout keep probability</li>
<li><strong>dp_output_keep_prob</strong> (<em>float</em>) – (default: 1.0) output dropout keep probability</li>
<li><strong>residual_connections</strong> (<em>bool</em>) – whether to add residual connection</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">TF RNN instance</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="parts.transformer.html" class="btn btn-neutral float-right" title="transformer" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="parts.html" class="btn btn-neutral" title="parts" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, NVIDIA.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.2',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script>  
  <style>
    /* Sidebar header (and topbar for mobile) */
    .wy-side-nav-search, .wy-nav-top {
      background: #64d81c;
    }
    .wy-side-nav-search > div.version {
      color: #ffffff;
    }
    .wy-side-nav-search > img {
      max-width: 150px;
    }
    .wy-side-nav-search > a {
      font-size: 23px;
    }
  </style>


</body>
</html>